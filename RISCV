module RISCV_Top(input clk, reset);
    // 1. Declare Pipeline Registers
    reg [63:0] IF_ID;   
    reg [150:0] ID_EX;  
    reg [100:0] EX_MEM; 
    reg [70:0] MEM_WB;  

    // 
    wire [31:0] pc;
    wire [31:0] instr;
    wire [31:0] data1, data2;
    wire [4:0]  rs1, rs2, rd;
    wire [10:0] ctrl; // Adjust width here based on your control unit
    
    wire stall;

    // 

    // 3. Update Pipeline Registers
    always @(posedge clk) begin
        if (reset) begin
            IF_ID  <= 0;
            ID_EX  <= 0;
            EX_MEM <= 0;
            MEM_WB <= 0;
        end else if (!stall) begin
            IF_ID  <= {pc, instr};             // Line 32
            ID_EX  <= {ctrl, data1, data2, rs1, rs2, rd}; // Line 33
        end
    end
endmodule

// ALU.v
module ALU (
    input [31:0] A, B,
    input [3:0] ALUControl,
    output reg [31:0] ALUResult,
    output Zero
);
    always @(*) begin
        case (ALUControl)
            4'b0000: ALUResult = A + B;    // ADD
            4'b0001: ALUResult = A - B;    // SUB
            4'b0010: ALUResult = A & B;    // AND
            4'b0011: ALUResult = A | B;    // OR
            4'b0100: ALUResult = A ^ B;    // XOR
            4'b0101: ALUResult = A << B[4:0]; // SLL
            4'b0110: ALUResult = A >> B[4:0]; // SRL
            default: ALUResult = 32'b0;
        endcase
    end
    assign Zero = (ALUResult == 0);
endmodule

// RegisterFile.v
module RegisterFile(
    input clk, reset, reg_write,
    input [4:0] rs1, rs2, rd,
    input [31:0] write_data,
    output [31:0] rd_data1, rd_data2
);
    reg [31:0] registers [31:0];
    integer i;

    assign rd_data1 = (rs1 == 0) ? 0 : registers[rs1];
    assign rd_data2 = (rs2 == 0) ? 0 : registers[rs2];

    always @(negedge clk or posedge reset) begin
        if (reset) begin
            for (i = 0; i < 32; i = i + 1) registers[i] <= 0;
        end else if (reg_write && rd != 0) begin
            registers[rd] <= write_data;
        end
    end
endmodule

// Hazard_Unit.v
module Hazard_Unit(
    input [4:0] rs1, rs2, ex_rd,
    input ex_memread,
    output reg stall
);
    always @(*) begin
        if (ex_memread && ((ex_rd == rs1) || (ex_rd == rs2)))
            stall = 1'b1;
        else
            stall = 1'b0;
    end
endmodule

// Forwarding_Unit.v
module Forwarding_Unit(
    input [4:0] ex_rs1, ex_rs2, mem_rd, wb_rd,
    input mem_regwrite, wb_regwrite,
    output reg [1:0] forwardA, forwardB
);
    always @(*) begin
        // Forward A
        if (mem_regwrite && (mem_rd != 0) && (mem_rd == ex_rs1)) forwardA = 2'b10;
        else if (wb_regwrite && (wb_rd != 0) && (wb_rd == ex_rs1)) forwardA = 2'b01;
        else forwardA = 2'b00;

        // Forward B
        if (mem_regwrite && (mem_rd != 0) && (mem_rd == ex_rs2)) forwardB = 2'b10;
        else if (wb_regwrite && (wb_rd != 0) && (wb_rd == ex_rs2)) forwardB = 2'b01;
        else forwardB = 2'b00;
    end
endmodule


// Testbench //

`timescale 1ns/1ps

module tb_top;
    reg clk;
    reg reset;

    // Instantiate your CPU
    RISCV_Top dut (
        .clk(clk),
        .reset(reset)
    );

    // Generate Clock (100MHz)
    always #5 clk = ~clk;

    initial begin
        // Initialize Waveform Dumping
        $dumpfile("riscv_trace.vcd");
        $dumpvars(0, tb_top);

        // Reset Sequence
        clk = 0;
        reset = 1;
        #20 reset = 0;

        // Run for 500ns then stop
        #500;
        $display("Simulation Finished. Open riscv_trace.vcd in GTKWave.");
        $finish;
    end
endmodule
